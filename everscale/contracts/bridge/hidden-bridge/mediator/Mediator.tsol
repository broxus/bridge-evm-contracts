pragma ever-solidity >= 0.62.0;

pragma AbiHeader expire;

import "./../../../utils/ErrorCodes.tsol";
import "./../../../utils/TransferUtils.tsol";
import "./../../interfaces/proxy/INetworks.tsol";
import "./../../interfaces/alien-token-merge/IMergePool.tsol";

import "@broxus/contracts/contracts/access/InternalOwner.tsol";
import "@broxus/contracts/contracts/libraries/MsgFlag.tsol";
import "@broxus/contracts/contracts/utils/CheckPubKey.tsol";

import "@broxus/contracts/contracts/utils/RandomNonce.tsol";
import "../../../utils/jetton/interfaces/ITransferNotification.tsol";
import "../../../utils/jetton/libraries/JettonUtils.tsol";


/// @title Mediator
/// @notice Used as part of hidden bridge for sol/evm-ever-sol/evm token transfers
/// An example:
/// 1. ETH USDT -> EVER USDT -> BNB USDT
/// 1.1 Mediator accepts EVER USDT mint and decodes the payload
/// 1.2 Payload says "Burn tokens in favour of proxy with some payload"
/// 1.3 Burn initiates creating an ever-evm event contract with BNB USDT withdrawal
/// - Support multiple event closers and event deployers
contract Mediator is
    ITransferNotification,
    INetworks,
    TransferUtils,
    InternalOwner,
    RandomNonce,
    CheckPubKey
{
    enum Operation {
        BurnToAlienProxy,
        BurnToMergePool,
        TransferToNativeProxy
    }

    address public nativeProxy;

    constructor(
        address _owner,
        address _nativeProxy
    ) checkPubKey {
        require(_owner != address(0), ErrorCodes.ZERO_ADDRESS);
        require(_nativeProxy != address(0), ErrorCodes.ZERO_ADDRESS);
        tvm.accept();

        setOwnership(_owner);
        nativeProxy = _nativeProxy;
    }

    function setNativeProxy(
        address _nativeProxy
    ) external onlyOwner cashBack {
        require(_nativeProxy != address(0), ErrorCodes.ZERO_ADDRESS);
        nativeProxy = _nativeProxy;
    }

    function transferNotification(
        uint64 /*_callId*/,
        varUint16 _amount,
        address _tokenSender,
        optional(TvmCell) _payload
    ) external override functionID(0x7362d09c) reserveAtLeastTargetBalance {
        _handleTokens(
            _payload.get(),
            msg.sender,
            _amount,
            _tokenSender
        );
    }

    function _handleTokens(
        TvmCell payloadWithNonce,
        address wallet,
        uint128 amount,
        address _tokenSender
    ) internal pure {
        (uint32 nonce, TvmCell payload) = abi.decode(payloadWithNonce, (uint32, TvmCell));

        (
            Operation operation,
            address proxy,
            TvmCell operationPayload
        ) = abi.decode(payload, (Operation, address, TvmCell));

        TvmCell withdrawPayload = _encodeWithdrawPayload(operation, operationPayload, nonce);

        if (operation == Operation.BurnToAlienProxy || operation == Operation.BurnToMergePool) {
            _burn(wallet, amount, proxy, withdrawPayload);
        } else if (operation == Operation.TransferToNativeProxy) {
            _transfer(wallet, amount, proxy, _tokenSender, withdrawPayload);
        }
    }

    function _encodeWithdrawPayload(
        Operation operation,
        TvmCell payload,
        uint32 nonce
    ) internal pure returns(TvmCell withdrawPayload) {
        if (operation == Operation.BurnToAlienProxy) {
            (
                , // ignore nonce
                Network network,
                TvmCell burnPayload
            ) = abi.decode(payload, (uint32, Network, TvmCell));

            withdrawPayload = abi.encode(nonce, network, burnPayload);
        } else if (operation == Operation.BurnToMergePool) {
            (
                , // ignore nonce
                IMergePool.BurnType burnType,
                address targetToken,
                TvmCell operationPayload
            ) = abi.decode(payload, (uint32, IMergePool.BurnType, address, TvmCell));

            withdrawPayload = abi.encode(nonce, burnType, targetToken, operationPayload);
        } else if (operation == Operation.TransferToNativeProxy) {
            (
                , // ignore nonce
                Network network,
                TvmCell transferPayload,
                string name,
                string symbol,
                uint8 decimals,
                address token,
                address remainingGasTo
            ) = abi.decode(payload, (
                uint32,
                Network,
                TvmCell,
                string,
                string,
                uint8,
                address,
                address
            ));

            withdrawPayload = abi.encode(
                nonce,
                network,
                transferPayload,
                name,
                symbol,
                decimals,
                token,
                remainingGasTo
            );
        } else {
            revert(ErrorCodes.UNKNOWN_MEDIATOR_OPERATION);
        }
    }

    function _transfer(
        address wallet,
        uint128 amount,
        address proxy,
        address remainingGasTo,
        TvmCell payload
    ) internal pure {
        uint128 callbackValue = payload.toSlice().empty()
            ? 0
            : _transferJettonsCallbackValue();

        JettonUtils.transferJettons(
            wallet,
            0,
            proxy,
            varUint16(amount),
            varUint16(callbackValue),
            payload,
            remainingGasTo,
            0,
            MsgFlag.ALL_NOT_RESERVED,
            false
        );
    }

    function _burn(
        address wallet,
        uint128 amount,
        address proxy,
        TvmCell payload
    ) internal pure {
        JettonUtils.burn(
            wallet,
            0,
            varUint16(amount),
            proxy, // <callbackTo> for AlienJetton
            payload,
            0,
            MsgFlag.ALL_NOT_RESERVED,
            false
        );
    }

    function upgrade(
        TvmCell code
    ) external onlyOwner {
        TvmCell data = abi.encode(
            owner,
            nativeProxy,
            _randomNonce
        );

        tvm.setcode(code);
        tvm.setCurrentCode(code);

        onCodeUpgrade(data);
    }

    function onCodeUpgrade(
        TvmCell data
    ) private {
        tvm.resetStorage();

        (
            owner,
            nativeProxy,
            _randomNonce
        ) = abi.decode(data, (address, address, uint));
    }
}
