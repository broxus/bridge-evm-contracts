pragma ever-solidity >= 0.62.0;
pragma AbiHeader expire;
pragma AbiHeader pubkey;


import "./interfaces/IStakingPool.tsol";
import "./interfaces/IUserData.tsol";
import "./interfaces/IUpgradableByRequest.tsol";

import "./../utils/ErrorCodes.tsol";
import "./libraries/Gas.tsol";
import "./interfaces/IUpgradableByRequest.tsol";

import "@broxus/contracts/contracts/libraries/MsgFlag.tsol";
import "@broxus/contracts/contracts/platform/Platform.tsol";

contract UserData is IUserData, IUpgradableByRequest {

    uint32 current_version;
    TvmCell platform_code;

    uint128 token_balance;

    RewardRoundData[] rewardRounds;

    address root; // setup from initialData
    address user; // setup from initialData

    uint256 constant SCALING_FACTOR = 1e18;

    // Cant be deployed directly
    constructor() public { revert(); }

    // ---------------- DAO -------------------

    function _reserve() internal pure returns (uint128) {
        return math.max(address(this).balance - msg.value, Gas.USER_DATA_INITIAL_BALANCE);
    }

    function getDetails() external responsible view override returns (UserDataDetails) {
        return { value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS }UserDataDetails(
            token_balance, current_version, rewardRounds,
            root, user
        );
    }

    function syncRewards(IStakingPool.RewardRound[] reward_rounds, uint256 updated_balance) internal {
        for (uint i = rewardRounds.length - 1; i < reward_rounds.length; i++) {
            if (i >= rewardRounds.length) {
                rewardRounds.push(RewardRoundData(0, 0));
            }

            IStakingPool.RewardRound remote_round = reward_rounds[i];
            RewardRoundData local_round = rewardRounds[i];

            uint128 new_reward = uint128(((token_balance * remote_round.accRewardPerShare) / SCALING_FACTOR) - local_round.reward_debt);
            rewardRounds[i].reward_balance += new_reward;
            rewardRounds[i].reward_debt = uint128((updated_balance * remote_round.accRewardPerShare) / SCALING_FACTOR);
        }
    }

    function processDeposit(
        uint64 nonce,
        uint128 _tokens_to_deposit,
        IStakingPool.RewardRound[] reward_rounds,
        uint32 code_version
    ) external override onlyRoot {
        tvm.rawReserve(_reserve(), 0);

        if (code_version > current_version) {
            IStakingPool(msg.sender).revertDeposit{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(nonce);
            return;
        }

        syncRewards(reward_rounds, token_balance + _tokens_to_deposit);
        token_balance += _tokens_to_deposit;

        emit DepositProcessed(_tokens_to_deposit, token_balance);
        IStakingPool(msg.sender).finishDeposit{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(nonce);
    }

    function processClaimReward(
        IStakingPool.RewardRound[] reward_rounds,
        address send_gas_to,
        uint32 code_version
    ) external override onlyRoot {
        require (code_version == current_version, ErrorCodes.LOW_VERSION);

        tvm.rawReserve(_reserve(), 0);

        syncRewards(reward_rounds, token_balance);

        uint128[] rewards = new uint128[](rewardRounds.length - 1);
        for (uint i = 0; i < rewardRounds.length - 1; i++) {
            rewards[i] = rewardRounds[i].reward_balance;
            rewardRounds[i].reward_balance = 0;
        }

        IStakingPool(msg.sender).finishClaimReward{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(user, rewards, send_gas_to);
    }

    function processWithdraw(
        uint128 _tokens_to_withdraw,
        IStakingPool.RewardRound[] reward_rounds,
        address send_gas_to,
        uint32 code_version
    ) external override onlyRoot {
        require (token_balance >= _tokens_to_withdraw, ErrorCodes.LOW_TOKEN_BALANCE);
        require (code_version == current_version, ErrorCodes.LOW_VERSION);

        tvm.rawReserve(_reserve(), 0);

        syncRewards(reward_rounds, token_balance - _tokens_to_withdraw);
        token_balance -= _tokens_to_withdraw;

        IStakingPool(msg.sender).finishWithdraw{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(user, _tokens_to_withdraw, send_gas_to);
    }

    function withdrawTons() external override onlyRoot {
        tvm.rawReserve(Gas.USER_DATA_INITIAL_BALANCE, 0);

        user.transfer({value: 0, flag: MsgFlag.ALL_NOT_RESERVED, bounce: false});
    }

    onBounce(TvmSlice /* slice */) external {}

    function onCodeUpgrade(TvmCell upgrade_data) private {
        tvm.resetStorage();
        tvm.rawReserve(_reserve(), 0);

        TvmSlice s = upgrade_data.toSlice();
        (address root_, , address send_gas_to) = s.decode(address, uint8, address);
        root = root_;

        platform_code = s.loadRef();

        TvmSlice initialData = s.loadRefAsSlice();
        user = initialData.decode(address);

        TvmSlice params = s.loadRefAsSlice();
        (current_version, ) = params.decode(uint32, uint32);

        rewardRounds.push(RewardRoundData(0, 0));

        send_gas_to.transfer({ value: 0, bounce: false, flag: MsgFlag.ALL_NOT_RESERVED });
    }

    function upgrade(TvmCell code, uint32 new_version, address send_gas_to) external override onlyRoot {
        if (new_version == current_version) {
            tvm.rawReserve(_reserve(), 0);
            send_gas_to.transfer({ value: 0, bounce: false, flag: MsgFlag.ALL_NOT_RESERVED });
        } else {
            emit UserDataCodeUpgraded(new_version);

            uint8 _tmp;
            TvmBuilder builder;
            builder.store(root); // address 267
            builder.store(_tmp); // 8
            builder.store(send_gas_to); // address 267

            builder.store(platform_code); // ref1

            TvmBuilder initial;
            initial.store(user); // address 267

            builder.storeRef(initial); // ref2

            TvmBuilder params;
            params.store(new_version); // 32
            params.store(current_version); // 32

            builder.storeRef(params); // ref3

            TvmBuilder data_builder;

            TvmBuilder builder_1;
            builder_1.store(token_balance); // 128
            builder_1.store(rewardRounds); // 33 + ref1

            data_builder.storeRef(builder_1); // ref1

            builder.storeRef(data_builder); // ref4

            // set code after complete this method
            tvm.setcode(code);

            // run onCodeUpgrade from new code
            tvm.setCurrentCode(code);
            onCodeUpgrade(builder.toCell());
        }
    }

    /*
    upgrade_data
        bits:
            address root
            uint8 dummy
            address send_gas_to
        refs:
            1: platform_code
            2: initial
                bits:
                    address user
            3: params:
                bits:
                    uint32 new_version
                    uint32 current_version
            4: data
                refs:
                    1: data_1
                        bits:
                            uint128 token_balance
                        refs:
                            1: rewardRounds
    */

    modifier onlyRoot() {
        require(msg.sender == root, ErrorCodes.NOT_ROOT);
        _;
    }
}
