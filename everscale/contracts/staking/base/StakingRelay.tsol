pragma ever-solidity >= 0.62.0;
pragma AbiHeader pubkey;
//pragma AbiHeader expire;

import "./StakingUpgradable.tsol";
import "../../bridge/interfaces/event-configuration-contracts/IEverscaleEthereumEventConfiguration.tsol";
import "../../bridge/interfaces/event-configuration-contracts/IEverscaleSolanaEventConfiguration.tsol";


abstract contract StakingPoolRelay is StakingPoolUpgradable {

    function setRelaysOnNewRound(
        uint160[] eth_keys,
        uint256[] ton_keys
    ) external override onlyAdminOrManager {
        require (now >= (round_details.currentRelayRoundStartTime + relay_config.timeBeforeSetRelays), ErrorCodes.TOO_EARLY_TO_SET_RELAYS);
        uint256 relays_count = ton_keys.length;
        require (relays_count == eth_keys.length, ErrorCodes.BAD_INPUT_ARRAYS);
        require (relays_count >= relay_config.minRelaysCount, ErrorCodes.NOT_ENOUGH_RELAYS);

        tvm.rawReserve(_reserve() - tonEthEventDeployValue - tonSolEventDeployValue, 2);

        uint32 start_time;
        uint32 round_num;
        // origin round
        if (round_details.currentRelayRound == 0 && round_details.currentRelayRoundStartTime == 0) {
            round_num = 0;
            start_time = now;
        } else {
            round_num = round_details.currentRelayRound + 1;

            // relays are set too late, start new round later
            if (now > round_details.currentRelayRoundEndTime - relay_config.minRoundGapTime) {
                start_time = now + relay_config.minRoundGapTime;
            // relays are set in time, start new round right after cur round
            } else {
                start_time = round_details.currentRelayRoundEndTime;
            }
        }
        uint32 end_time = start_time + relay_config.relayRoundTime;

        round_details.currentRelayRound = round_num;
        round_details.currentRelayRoundStartTime = start_time;
        round_details.currentRelayRoundEndTime = end_time;

        if (round_num > 0) {
            TvmBuilder event_builder;
            event_builder.store(round_num); // 32
            event_builder.store(eth_keys); // ref
            event_builder.store(end_time);
            IEverscaleEthereumEvent.EverscaleEthereumEventVoteData event_data_eth = IEverscaleEthereumEvent.EverscaleEthereumEventVoteData(tx.timestamp, now, event_builder.toCell());
            IEverscaleEthereumEventConfiguration(base_details.bridge_event_config_ton_eth).deployEvent{value: tonEthEventDeployValue}(event_data_eth);

            TvmBuilder event_builder2;
            event_builder2.store(round_num);
            event_builder2.store(ton_keys);
            event_builder2.store(end_time);
            IEverscaleSolanaEvent.EverscaleSolanaExecuteAccount[] _empty;
            IEverscaleSolanaEvent.EverscaleSolanaEventVoteData event_data_sol = IEverscaleSolanaEvent.EverscaleSolanaEventVoteData(tx.timestamp, now, _empty, false, _empty, event_builder2.toCell());
            IEverscaleSolanaEventConfiguration(bridge_event_config_ton_sol).deployEvent{value: tonSolEventDeployValue}(event_data_sol);
        }

        emit SetRelaysOnNewRound(round_num, start_time, end_time, uint32(eth_keys.length));
    }

}
